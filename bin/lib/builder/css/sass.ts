import * as fs from 'node:fs';
import * as path from 'node:path';
import { baseBuilder, builderOption } from '../base';
import { glob, Path } from 'glob';
import * as sass from 'sass';
import { rimraf } from 'rimraf';
import js_beautify from 'js-beautify';

/**
 * CSSビルドの設定オプション
 */
export interface sassBuilderOption extends builderOption {
  style?: 'expanded' | 'compressed';
  sourcemap?: boolean;
  /**
   * @todo 未実装
   */
  generateIndexFile?: boolean;
  /**
   * @todo 未実装
   */
  indexFileName?: string;
  /**
   * @todo 未実装
   */
  indexImportType?: 'use' | 'forward';
}

/**
 * ビルド処理の抽象クラス
 */
export class sassBuilder extends baseBuilder {
  /**
   * 出力先ディレクトリ
   */
  protected outputDir: string = 'public/assets/css';

  /**
   * エントリポイントとなるファイルの拡張子
   */
  protected fileExts: string[] = ['scss', 'sass', 'css'];

  /**
   * エントリポイントから除外するファイル名の接頭語
   */
  protected ignoreFilePrefix = '_';

  /**
   * エントリポイントから除外するディレクトリ名
   * (このディレクトリ名以下に配置されているファイルはエントリポイントから除外される)
   */
  protected ignoreDirNames = [];

  /**
   * 出力時の拡張子
   */
  protected outpuExt = 'css';

  /**
   * コンパイラーのオプション
   */
  protected compilerOption: any = {};

  /**
   * 出力スタイルの設定
   */
  private style?: 'expanded' | 'compressed';

  /**
   * SourceMapファイル出力の可否
   */
  private sourcemap?: boolean;

  /**
   * インデックスファイルの自動生成の可否
   * @todo 未実装
   */
  private generateIndexFile: boolean = true;

  /**
   * インデックスファイルの名前
   * @todo 未実装
   */
  private indexFileName: string = '_all.scss';

  /**
   * インデックスファイルにインポートする際の方法
   * @todo 未実装
   */
  private indexImportType: 'forward' | 'use' = 'forward';

  /**
   * コンストラクタ
   * @param option
   */
  constructor(option?: sassBuilderOption) {
    super();
    if (option) {
      this.setOption(option);
    }
  }

  /**
   * -------------------------
   * このクラス固有のメソッド
   * -------------------------
   */

  /**
   * 出力スタイルの設定
   *
   * @param style
   */
  public setStyle(style: 'expanded' | 'compressed'): void {
    this.style = style;
  }
  /**
   * SourceMapファイル出力の可否
   *
   * @param sourcemap
   */
  public setSourceMap(sourcemap: boolean): void {
    this.sourcemap = sourcemap;
  }

  /**
   * インデックスファイル名の名前を設定する
   *
   * @param indexFileName
   */
  public setIndexFileName(indexFileName: string): void {
    this.indexFileName = indexFileName;
  }
  /**
   * インデックスファイル名の名前を設定する
   *
   * @param generateIndexFile
   */
  public setGenerateIndexFile(generateIndexFile: boolean): void {
    this.generateIndexFile = generateIndexFile;
  }

  /**
   * インデックスファイルの生成処理
   *
   * @param filePath
   */
  protected generateIndex(filePath: string) {
    if (!this.generateIndexFile) {
      return;
    }
    const indexMatchPatterns = ['./_*.' + this.convertGlobPattern(this.fileExts), './*/' + this.indexFileName];
    const partialMatchFiles = glob
      .sync(indexMatchPatterns, {
        cwd: path.dirname(filePath),
      })
      .filter((partialFile) => {
        // 同一階層のインデックスファイルは除外
        return partialFile !== this.indexFileName;
      })
      .sort();
    const indexFilePath = path.join(path.dirname(filePath), this.indexFileName);
    let updateParentIndexFile = false;
    if (partialMatchFiles.length === 0) {
      updateParentIndexFile = true;
      rimraf(indexFilePath);
      console.log('Remove index file: ' + indexFilePath);
    } else {
      const partialFiles = {
        children: [],
        files: [],
      };
      partialMatchFiles.forEach((partialFile) => {
        if (partialFile.includes(path.sep)) {
          //@ts-ignore
          partialFiles.children.push(partialFile);
        } else {
          //@ts-ignore
          partialFiles.files.push(partialFile);
        }
      });
      let indexFileContents: string[] = [
        '// ===============================',
        '// Auto generated by sassBuilder',
        '// Do not edit this file!',
        '// ===============================',
      ];
      if (partialFiles.children.length > 0) {
        indexFileContents = indexFileContents.concat(
          partialFiles.children.map((file) => {
            return `@${this.indexImportType} '${file}';`;
          }),
        );
      }
      if (partialFiles.files.length > 0) {
        indexFileContents = indexFileContents.concat(
          partialFiles.files.map((file) => {
            return `@${this.indexImportType} '${file}';`;
          }),
        );
      }
      let actionName = 'Update';
      if (!fs.existsSync(indexFilePath)) {
        updateParentIndexFile = true;
        actionName = 'Generate';
      }
      fs.writeFileSync(indexFilePath, indexFileContents.join('\n') + '\n');
      console.log(actionName + ' index file: ' + indexFilePath);
    }
    //ルートディレクトリでない場合は親ディレクトリのインデックスファイルも更新
    if (updateParentIndexFile) {
      const relativePath = path.relative(this.srcDir, path.dirname(filePath));
      console.log('relativePath: ' + relativePath);
      if (path.dirname(relativePath) !== '.') {
        this.generateIndex(path.dirname(filePath));
      }
    }
  }
  /**
   * -------------------------
   * 既存メソッドのオーバーライド
   * -------------------------
   */

  /**
   * ビルドオプションを設定する
   *
   * @param option
   * @returns
   */
  public setOption(option: sassBuilderOption) {
    super.setOption(option);
    if (option.style !== undefined && option.style) {
      this.setStyle(option.style);
    }
    if (option.sourcemap !== undefined) {
      this.setSourceMap(option.sourcemap);
    }
    if (option.indexFileName !== undefined) {
      this.setIndexFileName(option.indexFileName);
    }
    if (option.generateIndexFile !== undefined) {
      this.setGenerateIndexFile(option.generateIndexFile);
    }
  }

  /**
   * コンパイルオプションを取得する
   * @returns
   */
  protected getCompileOption(): any {
    let compileOption = this.compileOption;
    if (this.style !== undefined) {
      compileOption = Object.assign(compileOption, { style: this.style });
    }
    if (this.sourcemap !== undefined) {
      compileOption = Object.assign(compileOption, { sourceMap: this.sourcemap });
    }
    return compileOption;
  }

  /**
   * ファイル追加時のコールバック処理
   * @param filePath
   */
  protected watchAddCallBack(filePath: string) {
    if (this.generateIndexFile && path.basename(filePath) === this.indexFileName) {
      return;
    }
    console.log('Add file: ' + filePath);
    if (this.generateIndexFile) {
      // インデックスファイルの生成/更新
      this.generateIndex.bind(this)(filePath);
    }
    try {
      //エントリポイントを更新
      this.getEntryPoint();
      if (Array.from(this.entryPoint.values()).includes(filePath)) {
        const outputPath = this.convertOutputPath(filePath);
        this.buildFile(filePath, outputPath);
      } else {
        this.buildAll();
      }
    } catch (error) {
      console.error(error);
      process.exit(1);
    }
  }
  protected watchChangeCallBack(filePath: string) {
    if (this.generateIndexFile && path.basename(filePath) === this.indexFileName) {
      return;
    }
    console.log('Update file: ' + filePath);
    try {
      if (Array.from(this.entryPoint.values()).includes(filePath)) {
        const outputPath = this.convertOutputPath(filePath);
        this.buildFile(filePath, outputPath);
        console.log('Compile: ' + filePath + ' => ' + outputPath);
      } else {
        this.buildAll();
      }
    } catch (error) {
      console.error(error);
      process.exit(1);
    }
  }
  protected watchUnlinkCallBack(filePath: string) {
    if (this.generateIndexFile && path.basename(filePath) === this.indexFileName) {
      return;
    }
    console.log('Remove file: ' + filePath);
    if (this.generateIndexFile) {
      // インデックスファイルの更新
      this.generateIndex.bind(this)(filePath);
    }
    if (Array.from(this.entryPoint.values()).includes(filePath)) {
      this.entryPoint.delete(filePath);
      const outputPath = this.convertOutputPath(filePath);
      rimraf(outputPath);
      console.log('Remove: ' + outputPath);
    }
  }

  /**
   * -------------------------
   * 抽象化メソッドの実装
   * -------------------------
   */

  /**
   * 単一ファイルのビルド処理
   * @param srcPath
   * @param outputPath
   */
  public async buildFile(srcPath: string, outputPath: string) {
    const compileOption = this.getCompileOption();
    const beautifyOption = this.getBeautifyOption('dummy.' + this.outpuExt);
    const result = sass.compile(srcPath, compileOption);
    if (compileOption.style !== 'compressed') {
      result.css = js_beautify.css(result.css, beautifyOption);
    }
    fs.mkdirSync(path.dirname(outputPath), { recursive: true });
    fs.writeFileSync(outputPath, result.css.trim() + '\n');
    if (result.sourceMap) {
      fs.writeFileSync(outputPath + '.map', JSON.stringify(result.sourceMap));
    }
  }

  /**
   * 全ファイルのビルド処理
   */
  public async buildAll() {
    const entries = this.getEntryPoint();
    if (entries.size > 0) {
      const compileOption = this.getCompileOption();
      const beautifyOption = this.getBeautifyOption('dummy.' + this.outpuExt);
      entries.forEach((srcFile, entryPoint) => {
        const outputPath = path.join(this.outputDir, entryPoint + '.' + this.outpuExt);
        const result = sass.compile(srcFile, compileOption);
        if (compileOption.style !== 'compressed') {
          result.css = js_beautify.css(result.css, beautifyOption);
        }
        fs.mkdirSync(path.dirname(outputPath), { recursive: true });
        fs.writeFileSync(outputPath, result.css.trim() + '\n');
        console.log('Compile: ' + srcFile + ' => ' + outputPath);
        if (result.sourceMap) {
          fs.writeFileSync(outputPath + '.map', JSON.stringify(result.sourceMap));
        }
      });
    }
  }
}
